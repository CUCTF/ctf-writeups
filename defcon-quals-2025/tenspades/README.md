# tenspades

## Summary

This challenge is a Linux CLI program that shuffles a standard 52-card deck
based on a linear congruential generator (LCG). The core vulnerability lies
in the predictability of the pseudo-random number generator, which allows the
attacker to deduce the shuffle sequence and win the game by guessing the correct
deck order. Don't gamble on pseudo-random!

**Artifacts:**

* tenspades: executable program provided by challenge authors
* solve.py: exploit script that predicts next shuffle

## Context

The tenspade challenge authors provide a domain and port that connect to the challenge.
They also provide the compiled challenge binary `tenspades`.

`tenspades` is written in C++ and runs as an interacteract CLI application.

First the program prints out a pre-shuffled deck in the encoded format of 2 characters for each card,
where the letter is one of `s, h, c, d` and represents the suit in a standard 52
card deck. The second character represents the rank of the cards, from `A, 2, ... K`.

The program then prints out a seed value and then asks the user to "show me your cards".
If the user input doesn't correcly guess the expected shuffle, then the program responds with
"Oh no, were you bluffing too?", and then reveals the correct shuffle result.

Then the program responds with another seed value, and continues looping through this until the
user successfully guesses the next deck shuffle.

```text
$ ./tenspades 
tenspades
sA s2 s3 s4 s5 s6 s7 s8 s9 sX sJ sQ sK hA h2 h3 h4 h5 h6 h7 h8 h9 hX hJ hQ hK cA c2 c3 c4 c5 c6 c7 c8 c9 cX cJ cQ cK dA d2 d3 d4 d5 d6 d7 d8 d9 dX dJ dQ dK 
seed: 2e368736
show me your cards 
sA s2 s3 s4 s5 s6 s7 s8 s9 sX sJ sQ sK hA h2 h3 h4 h5 h6 h7 h8 h9 hX hJ hQ hK cA c2 c3 c4 c5 c6 c7 c8 c9 cX cJ cQ cK dA d2 d3 d4 d5 d6 d7 d8 d9 dX dJ dQ dK
Oh no, were you bluffing too?
cK s9 cX hX dQ sA c2 d9 s4 dJ s8 d7 hJ h8 s7 c7 d6 h4 hK dK s5 hA s3 c6 sK sQ d5 d8 sX dX c4 cA d2 h2 h3 s2 dA c9 h5 c5 cJ c8 h9 cQ h7 d4 s6 sJ h6 c3 hQ d3 
seed: abbcc73
```

To win, the user must input the correct shuffle corresponding to the provided seed.

## Vulnerability

The randomness of the shuffle is generated with a pseudo random number generator, in the family of
[Linear Congruential Generators (LCG)](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle).

The LCG follows the standard formula:

```text
next = (a * current + c) % m
```

The LCG is setup at 0x102a80. The multiplier, `a` is set by an environment variable
`SEED` at `0x103100`. If no environment variable is set, it defaults to the value of
`1337`.

The initial value is set by a call to `std::random_device` at `0x102aa1`. The modulus is set
to Mersenne 31, or $2^{32} - 1$. The increment `c` is set to `2021`.

The shuffling algorithm takes place at 0x
The shuffling algorithm follows a [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle).
From a sorted deck, the
algorithm shuffles in place from the end of the deck, swapping cards based on
the "random" numbers generated by the LCG. Fisher-Yates shuffle is irreversible and is truly random,
when the random numbers used to shuffle it are also random.

```code
for i from n−1 down to 1 do
     j ← RNG.next() % (i)
     swap deck[j] and deck[i]
```

It's important to note that the another LCG is not initiated, and it just keeps iterating along the next sequence for each, but printing out each "53rd" value. But we only need input "n-1" which is given to us, to find the next 52.

Because the LCG is deterministic and its full internal state can be derived from a single
output value (the initial seed), the entire shuffle sequence becomes predictable—assuming
the attacker knows or can guess the LCG parameters (`a, c, m`). We only need to guess `a`
in this instance, which we can brute force by recreating the shuffle.

## Exploitation

The exploit utilizes the given seed to brute-force the multiplier, by checking that
it recreates the same shuffle sequence. Since the mulitplier is reused across rounds,
when we are given the initial seed value, we are able to predict the entire sequence.

Because we start out with `c` and `m` known, and given seed output, we can take the leaked correct shuffle to iterate all possible values of the multiplier `a`. By reconstructing the full shuffle, we are able to see if the value of `a` matches that in the LCG.

This technique works because `a` is only a 32-bit key, which is a small search space for this purpose.

Once we have `a`, we can use all our known parameters, and the given next `seed` to predict the next shuffle exactly.

**Exploit primitives:**

1. LCG State recovery (predictability of PRNGs)

## Remediation

This challenge lies in the fact that the randomness of the Fisher-Yates shuffle
relies on the randomness of the numbers inputed into it. LCG's do not provide
randomness and are notoriously reproducible with little evidence. PRNG's will get
you shot in Vegas!

Instead, a cryptographically secure random number generator should be used, such
as `std::random_device`, or equivalent in whichever language you choose. These
generators are resistant to prediction and ensure that even if an attacker observes
several outputs or internal states, they cannot feasibly deduce future values or
the underlying state.
