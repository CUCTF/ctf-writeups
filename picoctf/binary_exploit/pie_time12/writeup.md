# PicoCTF: PIE time 1 and 2

## Context (both levels)

We are provided with a compiled binary and the source code for each level, as well as a complimentary server and port to connect to via netcat. We only connect via netcat when we are ready to get the flag. The executable's details for each level will be explained below.

## Background Information: PIE executables and format string vulnerabilities

Executables can come in different forms, notably PIE (position independent executable) and no-PIE. If we compile a PIE executable, it means that that whole chunk of code for the program can be placed anywhere in memory. This enables ASLR (address space layout randomization) which randomizes the memory address of key components of our program, like where its stack, heap, etc. begin. A no-PIE executable's code will be placed at a fixed address. That means that we cannot use ASLR.

Below, I've provided examples of objdumped PIE and no-PIE executables. Note how the no-PIE executable starts at address 0x401000, while the PIE executable starts at 0x1000 so it's able to placed at a random memory address later.

``` text
mms2379@spoc:~/temp/studying/linking2$ objdump -d main-no-pie

main-no-pie:     file format elf64-x86-64


Disassembly of section .init:

0000000000401000 <_init>:
  401000:       f3 0f 1e fa             endbr64 
  401004:       48 83 ec 08             sub    $0x8,%rsp
  401008:       48 8b 05 e9 2f 00 00    mov    0x2fe9(%rip),%rax        # 403ff8 <__gmon_start__@Base>
  40100f:       48 85 c0                test   %rax,%rax
  401012:       74 02                   je     401016 <_init+0x16>
  401014:       ff d0                   call   *%rax
  401016:       48 83 c4 08             add    $0x8,%rsp
  40101a:       c3                      ret
...

```

```text
mms2379@spoc:~/temp/studying/linking2$ objdump -d main-dyn

main-dyn:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:       f3 0f 1e fa             endbr64 
    1004:       48 83 ec 08             sub    $0x8,%rsp
    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>
    100f:       48 85 c0                test   %rax,%rax
    1012:       74 02                   je     1016 <_init+0x16>
    1014:       ff d0                   call   *%rax
    1016:       48 83 c4 08             add    $0x8,%rsp
    101a:       c3                      ret
  ...

```

A format string vulnerability takes advantage of C's `printf(...)` to leak memory addresses. For example, if a program asks for user input and then prints that input back to the user using `printf(...)`, the user can supply a format string (`%s`, `%lx`, `%p`, etc.) so that their provided information gets printed in that form. Note that this is only possible when the `printf(...)` function **does not** already have a format string specifier. See the example below from OWASP.

``` C
#include  <stdio.h> 
void main(int argc, char **argv)
{
	// This line is safe
	printf("%s\n", argv[1]);

	// This line is vulnerable
	printf(argv[1]);
}
```
`./example "Hello World %p %p %p %p %p %p"` will result in: `Hello World 000E133E 000E133E 0057F000 CCCCCCCC CCCCCCCC CCCCCCCC`.

## Vulnerability (level 1)

When we do `./vuln` we are prompted to enter an address. If the address is not correct, we segfault:
```text
mms2379@spoc:~/ctf/pie_time$ ./vuln
Address of main: 0x58e94163433d
Enter the address to jump to, ex => 0x12345: 0x0
Your input: 0
Segfault Occurred, incorrect address.
```
Note that we are given the address of the `main` function. We may take a closer look at the source code. We see that we have a `main()` function and a `win` function that is not called anywhere in the program. We also see that `win` will give us our flag. Full source code can be found in `pie_time1/vuln.c`.
```C
int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered
  ...
```
Therefore, we conclude that we must somehow call the `win` function in order to get our flag. If this were a no-PIE exectuable, then we could just enter the address of the `win` function. Unfortunatley, `vuln` is a PIE executable:

```
mms2379@spoc:~/ctf/pie_time$ file vuln
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped
```



## Exploitation (level 1)



## Vulnerability (level 2)


## Exploitation (level 2)


## Remediation



# Sources/Credits

Written by Madalina Stoicov

- https://owasp.org/www-community/attacks/Format_string_attack 
